parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"kDVA":[function(require,module,exports) {
window.dashApp="\nimport pandas as pd\nimport jinja2\nimport markupsafe\nimport dash\nfrom dash import dcc\nfrom dash import html\n#import dash_core_components as dcc\n#import dash_html_components as html\nimport plotly.express as px\nimport pyodide\n\ndef set_data(data):\n    window.dataRetrieved = data\n\ndata = pyodide.open_url('https://plotly.github.io/datasets/country_indicators.csv')\ndf = pd.read_csv(data)\n\nexternal_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']\napp = dash.Dash(__name__, external_stylesheets=external_stylesheets)\n\navailable_indicators = df['Indicator Name'].unique()\n\napp.layout = html.Div([\n    html.Div([\n\n        html.Div([\n            dcc.Dropdown(\n                id='crossfilter-xaxis-column',\n                options=[{'label': i, 'value': i} for i in available_indicators],\n                value='Fertility rate, total (births per woman)'\n            ),\n            dcc.RadioItems(\n                id='crossfilter-xaxis-type',\n                options=[{'label': i, 'value': i} for i in ['Linear', 'Log']],\n                value='Linear',\n                labelStyle={'display': 'inline-block'}\n            )\n        ],\n        style={'width': '49%', 'display': 'inline-block'}),\n\n        html.Div([\n            dcc.Dropdown(\n                id='crossfilter-yaxis-column',\n                options=[{'label': i, 'value': i} for i in available_indicators],\n                value='Life expectancy at birth, total (years)'\n            ),\n            dcc.RadioItems(\n                id='crossfilter-yaxis-type',\n                options=[{'label': i, 'value': i} for i in ['Linear', 'Log']],\n                value='Linear',\n                labelStyle={'display': 'inline-block'}\n            )\n        ], style={'width': '49%', 'float': 'right', 'display': 'inline-block'})\n    ], style={\n        'borderBottom': 'thin lightgrey solid',\n        'backgroundColor': 'rgb(250, 250, 250)',\n        'padding': '10px 5px'\n    }),\n\n    html.Div([\n        dcc.Graph(\n            id='crossfilter-indicator-scatter',\n            hoverData={'points': [{'customdata': 'Japan'}]}\n        )\n    ], style={'width': '49%', 'display': 'inline-block', 'padding': '0 20'}),\n    html.Div([\n        dcc.Graph(id='x-time-series'),\n        dcc.Graph(id='y-time-series'),\n    ], style={'display': 'inline-block', 'width': '49%'}),\n\n    html.Div(dcc.Slider(\n        id='crossfilter-year--slider',\n        min=df['Year'].min(),\n        max=df['Year'].max(),\n        value=df['Year'].max(),\n        marks={str(year): str(year) for year in df['Year'].unique()},\n        step=None\n    ), style={'width': '49%', 'padding': '0px 20px 20px 20px'})\n])\n\n\n@app.callback(\n    dash.dependencies.Output('crossfilter-indicator-scatter', 'figure'),\n    [dash.dependencies.Input('crossfilter-xaxis-column', 'value'),\n     dash.dependencies.Input('crossfilter-yaxis-column', 'value'),\n     dash.dependencies.Input('crossfilter-xaxis-type', 'value'),\n     dash.dependencies.Input('crossfilter-yaxis-type', 'value'),\n     dash.dependencies.Input('crossfilter-year--slider', 'value')])\ndef update_graph(xaxis_column_name, yaxis_column_name,\n                 xaxis_type, yaxis_type,\n                 year_value):\n    dff = df[df['Year'] == year_value]\n\n    fig = px.scatter(x=dff[dff['Indicator Name'] == xaxis_column_name]['Value'],\n            y=dff[dff['Indicator Name'] == yaxis_column_name]['Value'],\n            hover_name=dff[dff['Indicator Name'] == yaxis_column_name]['Country Name']\n            )\n\n    fig.update_traces(customdata=dff[dff['Indicator Name'] == yaxis_column_name]['Country Name'])\n    fig.update_xaxes(title=xaxis_column_name, type='linear' if xaxis_type == 'Linear' else 'log')\n    fig.update_yaxes(title=yaxis_column_name, type='linear' if yaxis_type == 'Linear' else 'log')\n    fig.update_layout(margin={'l': 40, 'b': 40, 't': 10, 'r': 0}, hovermode='closest')\n\n    return fig\n\n\ndef create_time_series(dff, axis_type, title):\n    fig = px.scatter(dff, x='Year', y='Value')\n    fig.update_traces(mode='lines+markers')\n    fig.update_xaxes(showgrid=False)\n    fig.update_yaxes(type='linear' if axis_type == 'Linear' else 'log')\n    fig.add_annotation(x=0, y=0.85, xanchor='left', yanchor='bottom',\n                       xref='paper', yref='paper', showarrow=False, align='left',\n                       bgcolor='rgba(255, 255, 255, 0.5)', text=title)\n\n    fig.update_layout(height=225, margin={'l': 20, 'b': 30, 'r': 10, 't': 10})\n\n    return fig\n\n\n@app.callback(\n    dash.dependencies.Output('x-time-series', 'figure'),\n    [dash.dependencies.Input('crossfilter-indicator-scatter', 'hoverData'),\n     dash.dependencies.Input('crossfilter-xaxis-column', 'value'),\n     dash.dependencies.Input('crossfilter-xaxis-type', 'value')])\ndef update_y_timeseries(hoverData, xaxis_column_name, axis_type):\n    country_name = hoverData['points'][0]['customdata']\n    dff = df[df['Country Name'] == country_name]\n    dff = dff[dff['Indicator Name'] == xaxis_column_name]\n    title = '<b>{}</b><br>{}'.format(country_name, xaxis_column_name)\n    return create_time_series(dff, axis_type, title)\n\n\n@app.callback(\n    dash.dependencies.Output('y-time-series', 'figure'),\n    [dash.dependencies.Input('crossfilter-indicator-scatter', 'hoverData'),\n     dash.dependencies.Input('crossfilter-yaxis-column', 'value'),\n     dash.dependencies.Input('crossfilter-yaxis-type', 'value')])\ndef update_x_timeseries(hoverData, yaxis_column_name, axis_type):\n    dff = df[df['Country Name'] == hoverData['points'][0]['customdata']]\n    dff = dff[dff['Indicator Name'] == yaxis_column_name]\n    return create_time_series(dff, axis_type, yaxis_column_name)\n\n# This is not used in WebDash\n# if __name__ == '__main__':\n#     app.run_server(debug=True)\n";
},{}]},{},["kDVA"], null)
//# sourceMappingURL=/cross_filtering_app.1b6359c0.js.map